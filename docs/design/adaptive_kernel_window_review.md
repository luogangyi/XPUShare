# 技术评审报告：显存共享性能根因分析与改进方案

**评审对象**:
1. `docs/gpu_sharing_performance_analysis.md` - 根因分析
2. `docs/adaptive_kernel_window_design.md` - 改进方案

**评审日期**: 2026-01-28

---

## 一、根因分析评审

### 1.1 分析准确性评估

| 评审项 | 评价 | 说明 |
|--------|------|------|
| 现象描述 | ✅ 准确 | 清晰描述了 1.5s/it → 35s/it 的性能骤降现象 |
| 机制解释 | ✅ 准确 | 正确识别了 `Pending Kernel Window` 被重置为 1 是性能崩溃的直接原因 |
| 因果链条 | ✅ 完整 | 触发点(换页延迟) → 超时判定 → 窗口降级 → 流水线断裂 → 性能雪崩 |
| 数据佐证 | ⚠️ 需补充 | 分析依赖日志推断，缺少 `hook.c` 源码级验证。建议补充代码引用 |

### 1.2 待确认事项

1. **代码验证**: 需确认 `hook.c` 中确实存在 `if (duration > 10s) window = 1` 的逻辑。
   - **建议**: 在分析文档中引用具体代码行号或代码片段。

2. **触发条件精确性**: 文档提到"某次同步操作耗时超过 10 秒"，但未明确：
   - 是 `cuCtxSynchronize` 还是 `cuStreamSynchronize`？
   - 10 秒阈值是否可配置？
   - **建议**: 补充具体触发条件的代码引用。

3. **并发场景差异**: 为什么 `gpu-2`（首个独占运行）窗口能增长到 64，而后续任务无法恢复？
   - 分析文档给出了合理推测（切换后触发超时），但缺少对"窗口恢复机制"的描述。
   - **建议**: 补充现有代码中窗口如何增长的逻辑说明。

---

## 二、改进方案评审

### 2.1 方案完整性

| 改进点 | 评价 | 风险评估 |
|--------|------|----------|
| 预热豁免期 | ✅ 有效 | 低风险。需确定豁免期长度（30秒是否合理）需实测 |
| AIMD 算法 | ✅ 成熟 | 中风险。需调优参数（0.8/0.5 的衰减系数） |
| 滑动平均去噪 | ✅ 标准做法 | 低风险。Alpha 建议 0.3-0.5 |
| 窗口底限保护 | ✅ 关键改进 | 低风险。MIN_WINDOW=4 是合理的经验值 |

### 2.2 方案优势

1. **渐进降级**: 用乘性减代替断崖式重置，避免单次抖动导致性能雪崩。
2. **快速恢复**: 预热期+倍增恢复策略，使任务在抖动后能迅速回到高效模式。
3. **底线保护**: MIN_WINDOW=4 确保即使在最坏情况下也保留基本异步能力。

### 2.3 方案不足与建议

| 问题 | 风险等级 | 改进建议 |
|------|----------|----------|
| 缺少与调度器的协同 | 中 | 预热期应与调度器的 `LOCK_OK` 时间戳同步，需确认 `client.c` 中是否有此字段 |
| 参数未参数化 | 低 | 建议将 `WARMUP_SEC`, `CRITICAL_THRESHOLD`, `MIN_WINDOW` 设为环境变量可配置 |
| 缺少降级日志 | 低 | 当窗口被缩小时应打印 WARN 日志，便于运维诊断 |
| 未考虑恶意进程 | 中 | 当前方案对恶意进程的保护力度降低。建议增加"连续 N 次超时则强制降窗口"的兜底逻辑 |

### 2.4 伪代码审查

```c
// 原方案伪代码
if (sync_duration > CRITICAL_THRESHOLD) { // > 10s
    pending_kernel_window = max(4, pending_kernel_window / 2);
}
```

**审查意见**:
1. ✅ 逻辑正确。
2. ⚠️ 建议增加日志：`log_warn("Window reduced to %d due to sync timeout %fs", ...)`。
3. ⚠️ 连续超时处理缺失。建议增加：
   ```c
   static int consecutive_timeouts = 0;
   if (sync_duration > CRITICAL_THRESHOLD) {
       consecutive_timeouts++;
       if (consecutive_timeouts > 3) {
           pending_kernel_window = 1; // 真正的恶意占用，强制降到最低
       } else {
           pending_kernel_window = max(4, pending_kernel_window / 2);
       }
   } else {
       consecutive_timeouts = 0; // 重置计数
   }
   ```

---

## 三、综合评审结论

| 维度 | 根因分析 | 改进方案 |
|------|----------|----------|
| 技术准确性 | ⭐⭐⭐⭐ (4/5) | ⭐⭐⭐⭐ (4/5) |
| 完整性 | ⭐⭐⭐ (3/5) | ⭐⭐⭐⭐ (4/5) |
| 可操作性 | ⭐⭐⭐⭐ (4/5) | ⭐⭐⭐⭐ (4/5) |

### 建议的下一步行动

1. **代码验证**: 在 `hook.c` 中定位并引用 `pending_kernel_window` 相关逻辑，补充到分析文档。
2. **参数化配置**: 将关键阈值（预热时间、超时阈值、窗口底限）设为环境变量。
3. **增加诊断日志**: 在窗口调整时输出日志，便于生产环境诊断。
4. **连续超时保护**: 增加对真正恶意进程的兜底保护。
5. **实测验证**: 在 Kubernetes 环境重新运行 4-Pod 测试，验证改进效果。
